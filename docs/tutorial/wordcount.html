<!DOCTYPE HTML><html>
<head><meta charset="utf-8"><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" rel="stylesheet"><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script></head>
<body><div class="container"><div class="row"><div class="col-sm-12">
<h1>Example: WordCount</h1>
<p>In this example, we&#39;ll implement a simple pipeline which
calculates word frequencies in a plain text document. Our
example pipeline will make use of <code>PureEffect</code> and <code>IOEffect</code>, which
allow us to define our pipeline&#39;s tasks in terms of Haskell functions.</p>
<p>This example may look familiar to users of Apache Beam, which
also includes a WordCount example <a href="https://beam.apache.org/get-started/wordcount-example/">https://beam.apache.org/get-started/wordcount-example/</a>.</p>
<h2>Imports</h2>
<p>First, we&#39;ll need to import some additional modules which will enable us to
more easily work with text (<code>Data.Text</code>), define dictionaries/maps (<code>Data.Map</code>), perform
regex matching (<code>Text.Regex.Posix</code>), and more.</p>
<pre class="haskell"><code>{-# LANGUAGE Arrows #-}
{-# LANGUAGE OverloadedStrings #-}

import Data.List (sortBy)
import qualified Data.Map as Map
import Data.Ord (comparing)
import qualified Data.Text.IO as T
import qualified Data.Text as T
import Text.Printf (printf)
import Text.Regex.Posix ((=~))

import Funflow
</code></pre>
<h2>Helper Functions</h2>
<p>Since we&#39;re opting to write our pipeline using Haskell-based Flows, we need to define the Haskell
functions which will take care of parsing our input text and counting its words.</p>
<pre class="haskell"><code>-- | (word, n_occurences)
type TextCount = (T.Text, Int)

-- | Counts members in a list of text. Also works for lazy lists (e.g. data from readFile)
countWords :: [T.Text] -&gt; [TextCount]
countWords ws = let
        tally :: Map.Map T.Text Int -&gt; T.Text -&gt; Map.Map T.Text Int
        tally m k = if Map.member k m 
                    then Map.adjust (+1) k m
                    else Map.insert k 1 m
    in 
        Map.toList $ foldl tally Map.empty ws

-- | Removes punctuation marks from a text
removePunctuation :: T.Text -&gt; T.Text
removePunctuation = 
    let
        punctuation = &quot;,.?!:;\&quot;\&#39;&quot; :: String
    in T.filter (not . (`elem` punctuation))

-- | Filters words which are not comprised of latin characters (hyphens are allowed)
filterWords :: [T.Text] -&gt; [T.Text]
filterWords = 
    let 
        wordsRegex = &quot;[A-Za-z\&#39;]+&quot; :: String
    in filter $ (=~ wordsRegex) . T.unpack

-- | Like countWords, but with sorted results
countWordsSortedDesc :: [T.Text] -&gt; [TextCount]
countWordsSortedDesc = sortCountsDesc . countWords

-- | Sorts a list of word counts in descending order
sortCountsDesc :: [TextCount] -&gt; [TextCount]
sortCountsDesc = sortBy (flip $ comparing snd)

-- | Prepare word counts for printing
formatCounts :: [TextCount] -&gt; [T.Text]
formatCounts = map (\(w,c) -&gt; T.pack $ printf &quot;%s: %d&quot; (T.unpack w) c)
</code></pre>
<h2>Pipeline Definition</h2>
<p>With our core utility functions defined, we&#39;re ready to define our pipeline. One
simple way to structure our pipeline is to divide it into three tasks/operations:</p>
<ol>
<li>Read the input text file</li>
<li>Parse the input text and return a summary of the word frequencies in it</li>
<li>Write out our results. For this example, we can just write them directly to the terminal.</li>
</ol>
<p>Remember that in Funflow both tasks and a pipeline/DAG are described in terms of the same
type, a Flow. This is in contract to applications like Airflow, which separate out
tasks and pipelines into Operator and DAG objects.</p>
<pre class="haskell"><code>-- Individual task definitions (remember that each task is also a full &quot;Flow&quot;)
readDocument :: Flow String T.Text
readDocument = toFlow . IOEffect $ T.readFile

countWordsAndSummarize :: Flow T.Text T.Text
countWordsAndSummarize = toFlow . PureEffect $ (T.unlines . formatCounts . countWordsSortedDesc . filterWords. T.words . removePunctuation)

writeResult :: Flow (String, T.Text) ()
writeResult = let
        writeOutputMessage :: (String, T.Text) -&gt; IO ()
        writeOutputMessage (f, countText) = do
            T.putStrLn &quot;Normally we would write the result to a file with T.writeFile, but for this example we can instead print the output:&quot;
            T.putStrLn countText 
            return ()
    in toFlow . IOEffect $ writeOutputMessage

-- Build the final pipeline using the task Flows defined above
--   Note: Using arrow syntax to control which inputs get passed to
--   which pipeline tasks, i.e. result_name &lt;- task &lt;- task_input
flow :: Flow (String, String) ()
flow = proc (documentFilePath, outputSummaryFilePath) -&gt; do
    documentText &lt;- readDocument -&lt; documentFilePath
    countSummary &lt;- countWordsAndSummarize -&lt; documentText
    writeResult -&lt; (outputSummaryFilePath, countSummary)
</code></pre>
<h2>Run the pipeline</h2>
<p>And finally, with our pipeline defined, we&#39;re ready to run it!</p>
<div class="row">
<div class="col-md-1">
In
</div>
<div class="col-md-11">
<pre class="haskell"><code>runFlow defaultExecutionConfig flow ("words.txt":: String, "outputs/counts.txt"::String) :: IO ()
</code></pre>
</div>
</div>
<div class="row">
<div class="col-md-1">
Out
</div>
<div class="col-md-11">
<pre class="text"><code>Normally we would write the result to a file with T.writeFile, but for this example we can instead print the output:
a: 3
and: 3
try: 3
words: 3
Lets: 2
This: 2
count: 2
give: 2
it: 2
or: 2
pipeline: 2
FILE: 1
WordCounths: 1
basic: 1
contains: 1
haskell: 1
like: 1
list: 1
long: 1
not: 1
numbers: 1
of: 1
only: 1
punctuation: 1
should: 1
the: 1
to: 1
using: 1

()
</code></pre>
</div>
</div>
</div></div></div></body></html>
