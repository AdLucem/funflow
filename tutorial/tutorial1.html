<!DOCTYPE HTML><html>
<head><meta charset="utf-8"><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet"><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css" rel="stylesheet"><script src="https://ajax.googleapis.com/ajax/libs/jquery/1.12.4/jquery.min.js"></script><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script></head>
<body><div class="container"><div class="row"><div class="col-sm-12">
<h1>First steps with <code>funflow</code></h1>
<h2>Introduction</h2>
<p><code>funflow</code> is a Haskell library for defining and running <em>workflows</em>.
A workflow specifies a pipeline of <em>tasks</em> structured in a Direct Acyclic Graph (DAG).
Workflows in <code>funflow</code> have the great property of being composable which means that you can easily share and combine components across different workflows.
It supports type checking, result caching, and other features that simplify setting up your machinery.</p>
<p><em>Let&#39;s get started</em></p>
<h2>Anatomy of a Flow</h2>
<p>In <code>funflow</code>, we refer to workflows as <code>flows</code>.
A <code>Flow</code> takes an input and produces an output, and <code>funflow</code> describes it with a unique and simple type:</p>
<pre class="haskell"><code>flow :: Flow input output
</code></pre>
<p><code>input</code> and <code>output</code> are the types of the input and output values of the flow.
For instance a flow working on numbers might have the following type signature:</p>
<pre class="haskell"><code>flow :: Flow Int Int
</code></pre>
<p>It takes an integer as input and produces an integer as its output.
A flow that doesn&#39;t take any input can be written as:</p>
<pre class="haskell"><code>flow :: Flow () Int
</code></pre>
<p>Such a flow might request some user input or download some data.</p>
<h2>Tasks</h2>
<p>A <code>Flow</code> is a DAG comprising one or more <code>Tasks</code> which describe <strong>what</strong> you would like to execute.
<code>funflow</code> works with a wide range of task granularities.
A <code>Task</code> can be a simple Haskell function, a database query, a command to run in a Docker container, or more.</p>
<p>There are several different types of tasks in Funflow, each describing a specific type of computation.
Tasks are defined in the <code>Funflow.Tasks</code> subpackage.
The most basic task, the datatype <code>PureTask</code>, represents a pure Haskell function which has no <em>side effects</em> such as reading a file or running a command.
Other task datatypes include <code>IOTask</code>, which runs a Haskell function which can perform I/O (e.g. reading a file), and <code>DockerTask</code>, which runs a
<a href="https://docs.docker.com/get-docker/">Docker</a> container.</p>
<h2>How to create Flows</h2>
<p>The function <code>toFlow</code> is used to construct a <code>Flow</code>.
It can be imported from the top level <code>Funflow</code> module and is defined in <code>Funflow.Flow</code>.
It integrates a <code>Task</code> into a <code>Flow</code> which can then be composed with other flows into a larger, final <code>Flow</code> DAG.</p>
<p>Here is a <code>Flow</code> that runs a <code>PureTask</code>, incrementing its input by 1.</p>
<pre class="haskell"><code>flow :: Flow Int Int
flow = toFlow $ PureTask (+1)
</code></pre>
<p>In this example, <code>flow</code> is essentially a DAG with one node, <code>PureTask (+1)</code>.
Here is a flow that runs a simple IO task which prints its input.</p>
<pre><code>flow :: Flow String ()
flow = toFlow $ IOTask putStrLn
</code></pre>
<p>Single-task <code>Flows</code> like the ones above can also be created directly using their smart constructors.
For instance, instead of the previous, one can write:</p>
<pre><code>flow :: Flow Int Int
flow = pureFlow (+1)
</code></pre>
<p>or</p>
<pre><code>flow :: Flow String ()
flow = ioFlow putStrLn
</code></pre>
<p>Smart constuctors for other task types are defined in <code>Funflow.Flow</code>.</p>
<h2>Execute a flow</h2>
<p>Everything needed to run flows is available in the module <code>Funflow.Run</code>.
The function <code>runFlow</code> is the main way to execute a flow:</p>
<pre class="haskell"><code>runFlow flow input
</code></pre>
<p>where</p>
<ul>
<li><code>flow</code> is the <code>Flow</code> to run</li>
<li><code>input</code> is the input, with the same type as the input type of <code>flow</code></li>
</ul>
<p>It will return a result of type <code>IO output</code> where <code>output</code> is the output type of <code>flow</code>.
Let&#39;s run our flow from earlier:</p>
<div class="row">
<div class="col-md-1">
In
</div>
<div class="col-md-11">
<pre class="haskell"><code>runFlow flow (1 :: Int) :: IO Int
</code></pre>
</div>
</div>
<div class="row">
<div class="col-md-1">
Out
</div>
<div class="col-md-11">
<pre class="text"><code>2
</code></pre>
</div>
</div>
<p>As expected, it returned 2.</p>
<p>Astute readers may have noticed that the output of runFlow is of type <code>IO output</code> and not simply <code>output</code>.
This wrapping of <code>output</code> in <code>IO</code> happens because runFlow uses a context in which all possible Task types can be
executed. Since runFlow supports IO and Docker tasks, both of which utilize I/O, the output of runFlow is also of type <code>IO</code>.</p>
<h2>Next Steps</h2>
<p>With the basics out of the way, you should be ready to start writing your first <code>flows</code>. Check out the <a href="./wordcount.html">wordcount flow tutorial</a>
for a guided example.</p>
</div></div></div></body></html>
